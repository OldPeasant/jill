#!/usr/bin/python3
###############################################################################
#                                                                             #
#                        Jill system explorer v1.00.000                       #
#                                                                             #
###############################################################################
#                                                                             #
#          Copyright (c) 2020 Peter Max Guertler, coder@sonensei.ch           #
#                                                                             #
###############################################################################
#                                                                             #
# Permission is hereby granted, free of charge, to any person obtaining a     #
# copy of this software and associated documentation files (the "Software"),  #
# to deal in the Software without restriction, including without limitation   #
# the rights to use, copy, modify, merge, publish, distribute, sublicense,    #
# and/or sell copies of the Software, and to permit persons to whom the       #
# Software is furnished to do so, subject to the following conditions:        #
#                                                                             #
# The above copyright notice and this permission notice shall be included     #
# in all copies or substantial portions of the Software.                      #
#                                                                             #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER      #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING     #
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER         #
# DEALINGS IN THE SOFTWARE.                                                   #
#                                                                             #
###############################################################################


import json
import os

GRAPH_CHAR_UTF8 = {}
GRAPH_CHAR_UTF8['degree'] = '°C'
GRAPH_CHAR_UTF8['horizontal'] = '─'
GRAPH_CHAR_UTF8['vertical'] = '│'
GRAPH_CHAR_UTF8['corner-top-left'] = '╭'
GRAPH_CHAR_UTF8['corner-top-right'] = '╮'
GRAPH_CHAR_UTF8['corner-bottom-left'] = '╰'
GRAPH_CHAR_UTF8['corner-bottom-right'] = '╯'
GRAPH_CHAR_UTF8['tree-down-right-mid'] = '├'
GRAPH_CHAR_UTF8['tree-down-right-end'] = '└'

GRAPH_CHAR_ASCII = {}
GRAPH_CHAR_ASCII['degree'] = ' C'
GRAPH_CHAR_ASCII['horizontal'] = '-'
GRAPH_CHAR_ASCII['vertical'] = '|'
GRAPH_CHAR_ASCII['corner-top-left'] = '+'
GRAPH_CHAR_ASCII['corner-top-right'] = '+'
GRAPH_CHAR_ASCII['corner-bottom-left'] = '+'
GRAPH_CHAR_ASCII['corner-bottom-right'] = '+'
GRAPH_CHAR_ASCII['tree-down-right-mid'] = '+'
GRAPH_CHAR_ASCII['tree-down-right-end'] = '+'

CHAR_MODE_ASCII = "ascii"
CHAR_MODE_UTF8 = "utf8"

def print_sample(graph_char):
    print("> {}{}{} <".format(graph_char['corner-top-left'], graph_char['horizontal'], graph_char['corner-top-right']))
    print("> {}{}{} <".format(graph_char['vertical'], ' ', graph_char['vertical']))
    print("> {}{}{} <".format(graph_char['corner-bottom-left'], graph_char['horizontal'], graph_char['corner-bottom-right']))

def get_char_mode():
    print("Initial configuration of Jill")
    print("Depending on how you access Jill,")
    print("UTF-8 characters might or might not be supported")
    print("Check which of the two you see at all or which looks better:")
    print("-------------------")
    print("1. UTF-8")
    try:
        print_sample(GRAPH_CHAR_UTF8)
    except:
        print("Ooops, UTF-8 failed. Guess that's not an option")
    print("-------------------")
    print("2. ASCII")
    print_sample(GRAPH_CHAR_ASCII)
    print("-------------------")
    c = None
    while c not in ['u', 'a']:
        c = input("Please enter u or a (for UTF-8 or ASCII):")
    return {'u' : CHAR_MODE_UTF8, 'a' : CHAR_MODE_ASCII}[c]


CONF_PATH = os.path.expanduser("~/.jill")
if os.path.exists(CONF_PATH):
    with open(CONF_PATH) as f:
        CONF = json.loads(f.read())
else:
    char_mode = get_char_mode()
    # Defaults if no conf available
    CONF = {
        'max-width' : 800,
        'max-height' : 400,
        'max' : 10000,
        'char-mode' : char_mode
    }
    with open(CONF_PATH, 'w') as f:
        f.write(json.dumps(CONF, indent=2))


CHAR_MODE = CONF['char-mode']


GRAPH_CHAR = {}
if CHAR_MODE == CHAR_MODE_UTF8:
    GRAPH_CHAR = GRAPH_CHAR_UTF8
elif CHAR_MODE == CHAR_MODE_ASCII:
    GRAPH_CHAR = GRAPH_CHAR_ASCII
else:
    raise Exception("Unexpected CHAR_MODE '{}'".format(CHAR_MODE))

BATTERY_INFO = [
    ['charge_full', 'charge_now'],
    ['capacity', 'capacity_smb']
]
import json
import logging
import subprocess

MEM_UNITS = "B KB MB GB TB".split()

def partition(lst, chunk_size):
    result = []
    ix = 0
    while ix < len(lst):
        result.append(lst[ix:ix+chunk_size])
        ix += chunk_size
    return result

def read_single_line(path):
    try:
        with open(path, 'r') as f:
            data = f.read().replace('\n', '')
            return data
    except FileNotFoundError:
        # process no longer exists
        return None
    except OSError:
        # Could be empty file
        return None

def str_as_dict(txt, separator):
    result = {}
    for line in txt.splitlines():
        parts = line.split(separator)
        parts = [ p for p in parts if p]
        if len(parts) == 2:
            result[parts[0].strip()] = parts[1].strip()
        else:
            raise Exception("Can't split line '{}'".format(line))
    return result
    
def file_as_dict(file_path, separator=" "):
    with open(file_path) as f:
        return str_as_dict(f.read(), separator)

def command_as_dict(cmd, separator=None):
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    proc.wait()
    out, err = proc.communicate()
    if err:
        logging.error(err)
        raise Exception("Failed to run '{}'".format(cmd))
    return str_as_dict(out.decode("utf8"), separator)
    
def command_as_json(cmds):
    proc = subprocess.Popen(cmds, stdout=subprocess.PIPE)
    proc.wait()
    out, err = proc.communicate()
    if err:
        logging.error(err)
        raise Exception("Failed to run '{}'".format(cmds))
    return json.loads(out.decode("utf8"))

def time_to_str(t, include_seconds):
    seconds = t - 60 * int(t / 60)
    t = (t - seconds) / 60
    minutes = t - 60 * int(t / 60)
    t = (t - minutes) / 60
    hours = t - 24 * int(t / 24)
    if include_seconds:
        return "%.2d:%.2d:%.2d" % (hours, minutes, seconds)
    else:
        return "%.2d:%.2d" % (hours, minutes)

def format_memory(value, unit="B"):
    try:
        unit_index = MEM_UNITS.index(unit)
    except ValueError:
        return value

    while value > 10000 and unit_index < len(MEM_UNITS) - 1:
        value = value / 1024
        unit_index += 1
    return "{:2} {}".format(round(value, 2), MEM_UNITS[unit_index])

def intersect_y(x1, y1, x2, y2, y_target):
    if y1 == y2 or x1 == x2:
        return None
    m = (y2 - y1) / (x2 - x1)
    b = y1 - m * x1
    x = (y_target - b) / m
    return x

def split_evenly(amount_to_distribute, part_count):
    """Creates a list of integer of len part_count.
        The integers sum up to amount_to_distribute"""
    if part_count == 0:
        return []
    remaining = amount_to_distribute
    min_chunk = amount_to_distribute // part_count
    result = []
    for i in range(0, part_count):
        result.append(min_chunk)
        remaining -= min_chunk
    if remaining > part_count:
        raise Exception("Remaining is %d, part_count is %d" % (remaining, part_count))
    if remaining > 0:
        delta = part_count // remaining
        i = 0
        while i < part_count:
            if remaining > 0:
                result[i] += 1
                remaining -= 1
            i += delta
    if remaining > 0:
        raise Exception("Split evenly failed: Have %d left in the end" % remaining)
    return result


class Dispatcher:
    def __init__(self, default_handler):
        self.default_handler = default_handler
        self.handlers = {}
        self.keys = []

    def register(self, clazz, handler):
        for i in range(0, len(self.keys)):
            if self.keys[i] in clazz.__bases__:
                self.keys.insert(i, clazz)
                self.handlers[clazz] = handler
                return
        self.keys.append(clazz)
        self.handlers[clazz] = handler

    def get_handler(self, obj):
        for k in self.keys:
            if isinstance(obj, k):
                return self.handlers[k]
        return self.default_handler

# Decorator function
def dispatcher(default_handler):
    d = Dispatcher(default_handler)
    class DecoratorDispatcher:
        def register(self, clazz):
            def register_impl(specific_handler):
                d.register(clazz, specific_handler)
            return register_impl
        def __call__(self, *pos_args, **kw_args):
            d.get_handler(pos_args[0])(*pos_args, **kw_args)
    return DecoratorDispatcher()


class Packet:
    def __init__(self):
        self.items = []
        self.total = 0

    def __len__(self):
        return len(self.items)

    def append(self, item, size):
        self.items.append(item)
        self.total += size

class Filler:
    def __init__(self, max_packet_size):
        self.max_packet_size = max_packet_size
        self.packets = []

    def push_it(self):
        self.packets.append(Packet())
        return self.packets[len(self.packets) - 1]
    def add(self, item, size):
        if len(self.packets) == 0:
            self.push_it()
        last = self.packets[len(self.packets) - 1]
        if len(last) == 0:
            last.append(item, size)
            if last.total >= self.max_packet_size:
                self.push_it()
        else:
            if last.total + size > self.max_packet_size:
                last = self.push_it()
            last.append(item, size)
            
    def to_lists(self):
        outer = []
        for p in self.packets:
            outer.append(p.items)
        return outer

class LinkedListItem:
    def __init__(self, obj):
        self.obj = obj
        self.next = None
        self.prev = None

class LinkedList:
    def __init__(self):
        self.__current = None

    def __bool__(self):
        return bool(self.__current)

    def add(self, obj):
        if self.__current:
            lli = LinkedListItem(obj)
            lli.next = self.__current.next
            lli.prev = self.__current
            lli.next.prev = lli
            lli.prev.next = lli
            self.__current = lli
        else:
            lli = LinkedListItem(obj)
            lli.prev = lli
            lli.next = lli
            self.__current = lli

    def current(self):
        return self.__current.obj
    def next(self):
        self.__current = self.__current.next
        return self.__current.obj
    def prev(self):
        self.__current = self.__current.prev
        return self.__current.obj
    def items(self):
        result = list()
        t = self.__current
        result.append(t.obj)
        t = t.next
        while t != self.__current:
            result.append(t.obj)
            t = t.next
        return result

class ValueCounter:
    def __init__(self, some_dict):
        self.count = {}
        for v in some_dict.values():
            if v in self.count:
                self.count[v] += 1
            else:
                self.count[v] = 1

import curses
import datetime
import logging
import traceback


        

class LayoutConstraint:
    def __init__(self,
            min_width = 0, min_height = 0,
            stretch_x = False, stretch_y = True):
        self.min_width = min_width
        self.min_height = min_height
        self.stretch_x = stretch_x
        self.stretch_y = stretch_y

class Component:
    def __init__(self):
        self.__parent = None
        self.x = 0
        self.y = 0
        self.w = 0
        self.h = 0
        self.__min_width = 0
        self.__min_height = 0
        self.__stretch_x = False
        self.__stretch_y = False
        self.__layout_valid = False
        self.can_focus = False
        self.has_focus = False

    def set_cursor_safe(self, stdscr, x, y):
        try:
            stdscr.addstr(y, x, "")
        except:
            pass

    def set_cursor(self, stdscr, x, y):
        set_cursor_safe(stdscr, x, y)

    def update_from_model(self):
        # Default empty implementation
        pass

    def layout(self, w, h):
        self.w = w
        self.h = h
        self.layout_valid = True

    def write_safe(self, stdscr, x, y, max_x, max_y, txt, mode=curses.A_NORMAL):
        if y >= max_y or x > max_x:
            return
        try:
            stdscr.addstr(y, x, txt[:(max_x - x - 1)], mode)
        except:
            logging.info("Writing {}/{} {} failed".format(y, x, txt))

    @property
    def parent(self):
        return self.__parent

    @parent.setter
    def parent(self, p):
        if self.__parent is not None:
            raise Exception("%s already has a parent" % str(self))
        self.__parent = p

    @property
    def min_width(self):
        return self.__min_width

    @min_width.setter
    def min_width(self, w):
        if self.__min_width != w:
            self.__min_width = w
            self.layout_valid = False

    @property
    def min_height(self):
        return self.__min_height

    @min_height.setter
    def min_height(self, h):
        if self.__min_height != h:
            self.__min_height = h
            self.layout_valid = False

    @property
    def stretch_x(self):
        return self.__stretch_x

    @stretch_x.setter
    def stretch_x(self, s):
        if self.__stretch_x != s:
            self.__stretch_x = s
            self.layout_valid = False

    @property
    def stretch_y(self):
        return self.__stretch_y

    @stretch_y.setter
    def stretch_y(self, s):
        if self.__stretch_y != s:
            self.__stretch_y = s
            self.layout_valid = False

    @property
    def layout_valid(self):
        return self.__layout_valid

    @layout_valid.setter
    def layout_valid(self, v):
        if self.__layout_valid != v:
            self.__layout_valid = v
            if self.__parent and not v:
                self.__parent.layout_valid = False


class Container(Component):
    def __init__(self):
        super(Container, self).__init__()
        self.__components = []

    @property
    def components(self):
        return list(self.__components)

    def add(self, component):
        self.__components.append(component)
        component.parent = self
    def update_from_model(self):
        for c in self.__components:
            c.update_from_model()

    def write(self, stdscr, x, y, max_x, max_y):
        for child in self.__components:
            child.write(stdscr, x + child.x, y + child.y, min(x + child.x + child.w + 1, max_x), min(y + child.y + child.h + 1, max_y))

class HorizontalFlow(Container):

    def __init__(self):
        super(HorizontalFlow, self).__init__()

    def __str__(self):
        return "  HorizontalFlow"

    @property
    def stretch_y(self):
        for c in self.components:
            if c.stretch_y:
                return True
        return False

    @stretch_y.setter
    def stretch_y(self, s):
        raise Exception("Can't set stretch_y property on HorizontalFlow. It's determined by the stretch_y property of the contents")

    @property
    def min_height(self):
        m = 0
        for c in self.components:
            if m < c.min_height:
                m = c.min_height
        return m

    @min_height.setter
    def min_height(self, h):
        raise Exception("Property min_height is read-only in HorizontalFlow: \
                        Set min_height in contents")

    def layout(self, w, h):
        self.w = w
        self.h = h
        sum_min_width = 0
        count_stretchable_horizontal = 0
        for c in self.components:
            sum_min_width += c.min_width
            if c.stretch_x:
                count_stretchable_horizontal += 1
        to_distribute = max(0, w - sum_min_width)
        to_distribute_for_component = split_evenly(to_distribute, count_stretchable_horizontal)

        dist_index = 0
        x = 0
        for c in self.components:
            c.x = x
            c.y = 0
            new_width = c.min_width
            if c.stretch_x:
                new_width += to_distribute_for_component[dist_index]
                dist_index += 1
            c.w = new_width
            c.h = h
            c.layout(c.w, c.h)
            x += c.w
        self.layout_valid = True

class VerticalFlow(Container):

    def __str__(self):
        return "  VerticalFlow"

    def layout(self, w, h):
        self.w = w
        self.h = h
        sum_min_height = 0
        count_stretchable_vertical = 0
        for c in self.components:# all VerticalFlows
            sum_min_height += c.min_height
            if c.stretch_y:
                count_stretchable_vertical += 1
        to_distribute = max(0, h - sum_min_height)
        to_distribute_for_component = split_evenly(to_distribute, count_stretchable_vertical)

        dist_index = 0
        y = 0
        for c in self.components:
            row_height = c.min_height
            if c.stretch_y:
                row_height += to_distribute_for_component[dist_index]
                dist_index += 1
            c.x = 0
            c.y = y
            c.layout(w, row_height)
            y += row_height
        self.layout_valid = True

class Canvas(Component):
    def __init__(self):
        super(Canvas, self).__init__()
        self.clear()

    def layout(self, w, h):
        self.w = w
        self.h = h
        self.layout_valid = True

    def clear(self):
        self.buffer = [ [x] * CONF['max-width'] for x in [" "] * CONF['max-height']]

    def buffer_lines(self):
        lines = []
        for b in self.buffer:
            lines.append("".join(b))
        return lines

    def addstr(self, row, col, txt):
        self.buffer[row][col:(col+len(txt))] = list(txt)

    @property
    def components(self):
        return []
# Check these characters for borders
# ┘
# ┐
# ┌
# └
    
class TitledBorder(Container):
    def __init__(self, title, contained_component):
        super(TitledBorder, self).__init__()
        if contained_component.parent:
            raise Exception("Contained component {} already has parent {}".format(contained_component, contained_component.parent))
        self.title = title
        self.contained_component = contained_component
        self.add(contained_component)
        self.clear()

    def __str__(self):
        return "    TitledBorder[{}]".format(self.title)

    def clear(self):
        pass
        #self.buffer = [ [x] * CONF['max-width'] for x in [" "] * CONF['max-height']]
        #self.__draw_border()
        #self.addstr(0, 2, " {} ".format(self.title))

    def addstr(self, row, col, txt):
        self.buffer[row][col:(col+len(txt))] = list(txt)

    def __draw_border(self, stdscr, x, y, max_x, max_y):
        
        for rel_x in range(0, self.w):
            self.write_safe(stdscr, x + rel_x, y, max_x, max_y, GRAPH_CHAR['horizontal'])
            self.write_safe(stdscr, x + rel_x, y + self.h - 1, max_x, max_y, GRAPH_CHAR['horizontal'])
        for rel_y in range(0, self.h):
            self.write_safe(stdscr, x, y + rel_y, max_x, max_y, GRAPH_CHAR['vertical'])
            self.write_safe(stdscr, x + self.w - 1, y + rel_y, max_x, max_y, GRAPH_CHAR['vertical'])
        self.write_safe(stdscr, x, y, max_x, max_y, GRAPH_CHAR['corner-top-left'])
        self.write_safe(stdscr, x, y + self.h - 1, max_x, max_y, GRAPH_CHAR['corner-bottom-left'])
        self.write_safe(stdscr, x + self.w - 1, y, max_x, max_y, GRAPH_CHAR['corner-top-right'])
        self.write_safe(stdscr, x + self.w - 1, y + self.h - 1, max_x, max_y, GRAPH_CHAR['corner-bottom-right'])

        if self.contained_component.can_focus and self.contained_component.has_focus:
            style = curses.A_REVERSE
        else:
            style = curses.A_NORMAL
        self.write_safe(stdscr, x + 2, y, max_x, max_y, " {} ".format(self.title), style)
    def layout(self, w, h):
        cc = self.contained_component
        cc.x = 1
        cc.y = 1
        cc.layout(w - 2, h - 2)
        self.clear()
        self.layout_valid = True

    def write(self, stdscr, x, y, max_x, max_y):
        self.__draw_border(stdscr, x, y, max_x, max_y)
        super(TitledBorder, self).write(stdscr, x, y, max_x, max_y)

    @property
    def min_width(self):
        return self.contained_component.min_width + 2

    @min_width.setter
    def min_width(self, w):
        raise Exception("Can't set min_width of TitledBorder. Set it in contained component instead")

    @property
    def min_height(self):
        return self.contained_component.min_height + 2

    @min_height.setter
    def min_height(self, h):
        raise Exception("Can't set min_height of TitledBorder. Set it in contained component instead")

    @property
    def layout_valid(self):
        return self.contained_component.layout_valid

    @layout_valid.setter
    def layout_valid(self, v):
        if self.parent and not v:
            self.parent.layout_valid = False

    @property
    def stretch_x(self):
        return self.contained_component.stretch_x

    @stretch_x.setter
    def stretch_x(self, s):
        self.contained_component.stretch_x = s

    @property
    def stretch_y(self):
        return self.contained_component.stretch_y

    @stretch_y.setter
    def stretch_y(self, s):
        self.contained_component.stretch_y = s

class TableColumn:
    def __init__(self, caption, min_width=None, max_width=None, visible=True):
        self.caption = caption
        self.min_width = min_width
        self.max_width = max_width
        self.visible = visible

class Table(Canvas):
    def __init__(self, columns=None, grower=True, row_limit=None,
                       always_highlight_selection=False, show_header=False):
        super(Table, self).__init__()
        self.columns = []
        if columns:
            self.columns.extend(columns)
        self.grower = grower
        self.row_limit = row_limit
        self.always_highlight_selection = always_highlight_selection
        self.show_header = show_header
        self._data = []
        self.col_widths = []
        for c in self.columns:
            self.col_widths.append(c.min_width if c.min_width and c.visible else 0)
        self.selected_row_index = 0

    def set_cursor(self, stdscr, x, y):
        """Don't set the cursor in a table"""
        pass

    def handle_key(self, key):
        header_offset = 1 if self.show_header else 0
        if key == ord('j') or key == curses.KEY_DOWN:
            self.selected_row_index += 1
            if self.selected_row_index >= len(self._data):
                self.selected_row_index = len(self._data) - 1
        elif key == ord('k') or key == curses.KEY_UP:
            self.selected_row_index -= 1
        if self.selected_row_index < 0:
            self.selected_row_index = 0

    def __str__(self):
        return "      "+ self.__class__.__name__

    def layout(self, w, h):
        self.w = w
        self.h = h
        self.layout_valid = True

    def _extend_data_list(self, row_index, col_index):
        while len(self._data) <= row_index:
            self._data.append([])
        while len(self._data[row_index]) <= col_index:
            self._data[row_index].append("")
        while len(self.col_widths) <= col_index:
            self.col_widths.append(0)
            self.columns.append(TableColumn(""))

    def clear_table(self):
        self._data = []
        #self.scroll_offset = 0

    def set_value(self, row, column, value):
        self._extend_data_list(row, column)
        self._data[row][column] = value
        if self.columns[column].visible and len(value) > self.col_widths[column]:
            self.col_widths[column] = len(value)
            if self.columns[column].max_width and self.columns[column].max_width < self.col_widths[column]:
                self.col_widths[column] = self.columns[column].max_width
            sum = 0
            for s in self.col_widths:
                sum += s
            self.min_width = sum + len(self.col_widths) - 1
        if self.row_limit:
            self.min_height = min(self.row_limit, len(self._data))
        else:
            self.min_height = len(self._data)

    def write(self, stdscr, x, y, max_x, max_y):
        if self.show_header:
            header_offset = 1
            cell_x = x
            for col_index, col in enumerate(self.columns):
                if col.visible:
                    txt = self.columns[col_index].caption.ljust(self.col_widths[col_index] + 1)
                    self.write_safe(stdscr, cell_x, y, max_x, max_y, txt, curses.A_REVERSE)
                cell_x += self.col_widths[col_index] + (1 if col.visible else 0)
        else:
            header_offset = 0
        scroll_offset = max(0, self.selected_row_index - self.h + header_offset + 1)
        for row_index, row in enumerate(self._data):
            if row_index - scroll_offset >= 0 and row_index - scroll_offset < self.h - header_offset:
                style = curses.A_NORMAL
                if self.has_focus:
                    # selected row as A_REVERSE
                    if row_index == self.selected_row_index:
                        style = curses.A_REVERSE
                else:
                    if self.always_highlight_selection:
                        # selected row and the one above as underline
                        if row_index == self.selected_row_index or row_index + 1 == self.selected_row_index:
                            style = curses.A_UNDERLINE
                    
                cell_y = y + row_index - scroll_offset + header_offset
                cell_x = x
                for col_index, cell in enumerate(row):
                    if self.columns[col_index].visible:
                        txt = cell.ljust(self.col_widths[col_index] + 1)
                        self.write_safe(stdscr, cell_x, cell_y, max_x, max_y, txt, style)
                    cell_x += self.col_widths[col_index] + (1 if self.columns[col_index].visible else 0)

class Label(Canvas):
    def __init__(self, text, style=curses.A_NORMAL, width=None):
        super(Label, self).__init__()
        self.text = text
        self.style = style
        self.width = width

    def write(self, stdscr, x, y, max_x, max_y):
        if self.width:
            txt = self.text.ljust(self.width)
        else:
            txt = self.text
        txt = txt[:min(self.w, max_x - x)]
        self.write_safe(stdscr, x, y, max_x, max_y, txt, self.style)

class InputField(Canvas):
    def __init__(self, name=None):
        super(InputField, self).__init__()
        self.can_focus = True
        self.value = ""
        self.name = name
    def write(self, stdscr, x, y, max_x, max_y):
        mode = curses.A_REVERSE if self.has_focus else curses.A_NORMAL
        if len(self.value) > self.w:
            txt = self.value[(len(self.value)-self.w):]
        else:
            txt = self.value.ljust(self.w)
        txt = txt[:max_x - x]
        self.write_safe(stdscr, x, y, max_x, max_y, txt, mode)
    def set_cursor(self, stdscr, x, y):
        dx = min(self.w - 1, len(self.value))
        self.set_cursor_safe(stdscr, x + dx, y)
        
    def handle_key(self, key):
        if key == 263:
            self.value = self.value[:len(self.value)-1]
        elif key >= 32  and key <= 126: # 'normal' characters
            self.value += chr(key)

class FilterTable(Container):
    def __init__(self, table_columns, always_highlight_selection=False):
        super(FilterTable, self).__init__()
        self.columns = table_columns
        self.search_fields = []
        self.create_contents(always_highlight_selection)
        self.layout_valid = True


    def create_contents(self, always_highlight_selection):
        x = 0
        for c in self.columns:
            fld = InputField(c.caption)
            fld.x = x
            fld.y = 0
            fld.w = c.max_width
            fld.h = 1
            fld.layout_valid = True
            fld.can_focus = c.visible
            self.search_fields.append(fld)
            self.add(fld)
            x += c.max_width + (1 if c.visible else 0)

        self.table = Table(always_highlight_selection = always_highlight_selection, columns=self.columns, show_header = True)
        self.table.can_focus = True
        self.table.x = 0
        self.table.y = 1
        self.add(self.table)
        
    def clear_table(self):
        self.table.clear_table()

    def set_value(self, row, column, value):
        self.table.set_value(row, column, value)
    
    def search_values(self):
        result = {}
        for s in self.search_fields:
            result[s.name] = s.value
        return result

    def clear(self):
        self.buffer = [ [x] * CONF['max-width'] for x in [" "] * CONF['max-height']]
        self.addstr(0, 0, "*")

    def layout(self, w, h):
        self.w = w
        self.h = h
        self.table.h = h - 1
        self.table.w = w - 0
        self.layout_valid = True
        x = 0
        for i, s in enumerate(self.search_fields):
            col_width = self.table.col_widths[i]
            s.x = x
            s.w = col_width + 1
            x += s.w

def component_coordinates_to_str(c):
    return "(%d, %d)-(%d, %d)" % (c.x, c.y, c.x + c.w, c.y + c.h)

@dispatcher
def print_component_tree(something, lines, indent):
    lines.append(" " * indent + str(something))

@print_component_tree.register(Component)
def _(component, lines, indent):
    lines.append("%sComponent[%s]%s {layout %s}" % (" " * indent, component.__class__.__name__, component_coordinates_to_str(component), str(component.layout_valid)))

@print_component_tree.register(Container)
def _(container, lines, indent):
    lines.append("%sContainer[%s]%s {layout %s}" % (" " * indent, container.__class__.__name__, component_coordinates_to_str(container), str(container.layout_valid)))
    for c in container.components:
        print_component_tree(c, lines, indent + 1)

def print_full_component(component):
    return "\n".join(full_components_as_list(component))

def full_components_as_list(component):
    lines = []
    print_component_tree(component, lines, 0)
    return lines

class Controller:
    def __init__(self, tui):
        self.tui = tui

    def next_screen(self):
        self.tui.current_screen_index = (self.tui.current_screen_index + 1) % len(self.tui.screens)

class FocusManager():
    def __init__(self, root_component):
        self.focusable_components = LinkedList()
        self.__find_all_focusable(root_component)
        if self.focusable_components:
            self.focusable_components.next()
    def __find_all_focusable(self, comp):
        if comp.can_focus:
            self.focusable_components.add(comp)
        if isinstance(comp, Container):
            for child in comp.components:
                self.__find_all_focusable(child)
    def next(self):
        curr = self.focusable_components.current()
        if curr:
            curr.has_focus = False
            self.focusable_components.next().has_focus = True
    def prev(self):
        curr = self.focusable_components.current()
        if curr:
            curr.has_focus = False
            self.focusable_components.prev().has_focus = True

class Screen:
    def __init__(self, root_component):
        self.root_component = root_component
        self.focus_mgr = FocusManager(root_component)

    def __set_cursor(self, stdscr, x, y, components):
        last = components.pop()
        if len(components) > 0:
            self.__set_cursor(stdscr, x + last.x, y + last.y, components)
        else:
            last.set_cursor(stdscr, x + last.x, y + last.y)

    def write(self, stdscr):
        stdscr.clear()
        max_y, max_x = stdscr.getmaxyx()
        self.root_component.write(stdscr, 0, 0, max_x, max_y)
        in_focus = self.focus_mgr.focusable_components.current()
        if in_focus:
            path = []
            p = in_focus
            while p:
                path.append(p)
                p = p.parent
            self.__set_cursor(stdscr, 0, 0, path)

    def focus_prev(self):
        if self.focus_mgr.focusable_components:
            self.focus_mgr.prev()

    def focus_next(self):
        if self.focus_mgr.focusable_components:
            self.focus_mgr.next()

    def handle_key(self, c):
        f = self.focus_mgr.focusable_components.items()
        if f:
            f[0].handle_key(c)

class Tui:
    def __init__(self, stdscr):
        self._stdscr = stdscr
        self._screens = []
        self._current_screen_index = -1
        self._controller = Controller(self)

    def add_screen(self, s):
        self._screens.append(s)
        s.controller = self._controller
        if self._current_screen_index < 0:
            self._current_screen_index = 0

    @property
    def current_screen(self):
        return self._screens[self._current_screen_index]

    def handle_key(self, c):
        sc = self.current_screen
        if c == curses.KEY_RESIZE:
            max_y, max_x = self._stdscr.getmaxyx()
            sc.resized(max_y, max_x)
        elif c == 9: # TAB
            sc.focus_next()
        elif c == 353: # SHIFT-TAB
            sc.focus_prev()
        elif c == -1: # Timeout, no key pressed
            #sc.time_tick()
            pass
        else: # let current screen decide what to do
            sc.handle_key(c)
        sc.time_tick()
        if not sc.view.layout_valid:
            sc.view.layout(sc.cols, sc.rows)
        #for l in full_components_as_list(sc.view):
        #    logging.info("==>{}".format(l))
        sc.write(self._stdscr)
        self._stdscr.refresh()
        
        
        #logging.info("==== Components that can get focus: ====")
        #for c in sc.focus_mgr.focusable_components.items():
        #    logging.info("  {}: {}".format(c, c.has_focus))
        #logging.info("========================================")

    def event_loop(self):
        self.handle_key(curses.KEY_RESIZE)
        while (True):
            try:
                c = self._stdscr.getch()
                self.handle_key(c)
            except KeyboardInterrupt:
                return


class curses_tui:

    def __init__(self, *, halfdelay):
        self.halfdelay = halfdelay

    def __enter__(self):
        logging.info("=============== START CURSES ===============")
        self.stdscr = curses.initscr()
        curses.noecho();
        curses.cbreak();
        self.stdscr.keypad(1)
        curses.halfdelay(self.halfdelay)
        return Tui(self.stdscr)

    def __exit__(self, ex_type, value, tb):
        if tb:
            logging.info("=============== CURSES FAILED ===============")
            logging.error("%s: %s" % (str(ex_type), str(value)))
            for l in traceback.format_tb(tb):
                for p in l.split("\n"):
                    if p:
                        logging.error(p)
        else:
            logging.info("=============== ENDEDS CURSES ===============")
        curses.nocbreak();
        self.stdscr.keypad(0);
        curses.echo()
        curses.endwin()



import datetime
import json
import os
import string
import sys
import time
import traceback

import logging


POWER_SUPPLY_PATH = '/sys/class/power_supply/'

class TreeChars:
        def __init__(self, vert_not_last, vert_last, this_not_last, this_last):
                self.vert_not_last = vert_not_last
                self.vert_last = vert_last
                self.this_not_last = this_not_last
                self.this_last = this_last

        @staticmethod
        def build():
                vert_not_last = GRAPH_CHAR['vertical'] + " " * 3
                vert_last = " " * 4
                this_not_last = GRAPH_CHAR['tree-down-right-mid'] + GRAPH_CHAR['horizontal'] * 2 + " "
                this_last = GRAPH_CHAR['tree-down-right-end'] + GRAPH_CHAR['horizontal'] * 2 + " "
                return TreeChars(vert_not_last, vert_last, this_not_last, this_last)


TREE_CHARS = TreeChars.build()

CLOCK_TICKS = int(os.sysconf("SC_CLK_TCK"))

PROC_STAT_DESC = {
    '0' : "Process Zero",
    'R' : "Running",
    'S' : "Sleeping",
    'D' : "Waiting in uninterruptable disk sleep",
    'Z' : "Zombie",
    'T' : "Stopped (on a signal)",
    't' : "Tracing stop",
    'W' : "Paging",
    'X' : "Dead",
    'x' : "Dead (2.6.33-3.13)",
    'K' : "Wakekill",
    'W' : "Waking",
    'P' : "Parked",
    'I' : "Idle"
}

		

class CommandCache:
    def __init__(self):
        self.commands = {}

    @staticmethod
    def _sanitize_string(s):
        r = ""
        for c in s:
            #if (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z'):
            if ord(c) > 0:
                r = r + c
            else:
                r = r + ' '
        return r

    def get_command(self, pid, starttime):
        key = "%d%d" % (pid, starttime)
        if key in self.commands:
            return self.commands[key]
        try:
            command_line = read_single_line("/proc/%d/cmdline" % pid)
            if command_line:
                command_line = CommandCache._sanitize_string(command_line)
            else:
                command_line = read_single_line("/proc/%d/comm" % pid)
            if not(command_line):
                command_line = "** command not found **"
        except:
            err = traceback.format_exc()
            command_line = "ERR: %s" % str(err) # + p[1].split("(")[1].split(")")[0]
        self.commands[key] = command_line
        return command_line


class SELinuxInfo:
    def __init__(self):
        self.reload()

    def reload(self):
        try:
            values = command_as_dict('sestatus', ':')
        except FileNotFoundError:
            values = {}
        self.status = values.get('SELinux status', 'n/a')
        self.policy = values.get('Loaded policy name', 'n/a')
        self.mode = values.get('Current mode', 'n/a')
        self.mls = values.get('Policy MLS status', 'n/a')

    @property
    def enabled(self):
        return self.status == 'enabled'

    def __str__(self):
        return "SELinfoInfo[{}, {}, {}, {}]".format(self.status, self.policy, self.mode, self.mls)

    def __call__(self):
        return self.enabled

class AppArmorInfo:
    def __init__(self):
        self.reload()
    def reload(self):
        self.process_status = {}
        self.process_profile = {}
        self.pids = set()
        try:
            s = command_as_json(['apparmor_status', '--json'])
        except FileNotFoundError:
            self.enabled = False
            return
        except json.decoder.JSONDecodeError:
            self.enabled = None
            return
        self.enabled = True
        self.count_mode = ValueCounter(s['profiles']).count
        for path, details in s['processes'].items():
            for d in details:
                pid = int(d['pid'])
                profile = d['profile']
                status = d['status']
                self.pids.add(pid)
                self.process_status[pid] = status
                self.process_profile[pid] = profile

    def __call__(self):
        return self.enabled
#############################################################################
# /etc user modelling
#############################################################################

class UserSnapshot:
    def __init__(self):
        self.username_by_uid = {}
        with open("/etc/passwd", 'r') as f:
            for l in f.read().splitlines():
                parts = l.split(":")
                username = parts[0]
                uid = int(parts[2])
                self.username_by_uid[uid] = username


#############################################################################
# /proc modelling
#############################################################################
def find_battery_paths():
    paths = []
    for cand in os.listdir(POWER_SUPPLY_PATH):
        if os.path.exists(os.path.join(POWER_SUPPLY_PATH, cand, 'capacity')):
            paths.append(cand)
    return paths

class PowerSnapshot:
    def __init__(self, battery_path):
        self.time = time.time()
        self.capacity = int(read_single_line(os.path.join(POWER_SUPPLY_PATH, battery_path, 'capacity')))
        self.status = read_single_line(os.path.join(POWER_SUPPLY_PATH, battery_path, 'status'))

    def __str__(self):
        return "PowerSnapshot[{}, {}, {}, {}".format(self.name, self.charge_full, self.charge_now, self.status)

class PowerInfo:
    def __init__(self, battery_path):
        self.battery_path = battery_path
        self.snapshots = []
        self.take_snapshot()

    def take_snapshot(self):
        new_snapshot = PowerSnapshot(self.battery_path)
        needs_update = False
        if self.snapshots:
            latest_snapshot = self.snapshots[len(self.snapshots) - 1]
            if new_snapshot.status != latest_snapshot.status:
                self.snapshots = [new_snapshot]
                needs_update = True
            else:
                if latest_snapshot.capacity != new_snapshot.capacity:
                    self.snapshots.append(new_snapshot)
                    needs_update = True
        else:
            self.snapshots.append(new_snapshot)
            needs_update = True
        if not needs_update:
            return
        self.status = new_snapshot.status
        self.capacity = new_snapshot.capacity
        if len(self.snapshots) > 2:
            last = self.snapshots[len(self.snapshots) - 1]
            for s in self.snapshots[:len(self.snapshots)-1]:
                if self.status == 'Discharging' or self.status == "Not charging":
                    sec = intersect_y(s.time, s.capacity, last.time, last.capacity, 5.0)
                    if sec:
                        remain = sec - last.time
                    else:
                        remain = None
                elif self.status == 'Charging':
                    sec = intersect_y(s.time, s.capacity, last.time, last.capacity, 100.0)
                    if sec:
                        remain = sec - last.time
                    else:
                        remain = None
                else:
                    remain = None
                if remain:
                    txt = time_to_str(remain, False)
                else:
                    txt = ''
                #logging.info("Power {}-{} : {}".format(time_to_str(s.time, False), time_to_str(last.time, False), txt))
                self.time_remaining_str = txt
        else:
            self.time_remaining_str = ''

class ThermalZone:
    def __init__(self, zone_type, zone_temp):
        self.zone_type = zone_type
        self.zone_temp = zone_temp

class ThermalInfo:
    def __init__(self):
        self.thermal_zones = []
        for tz in os.listdir("/sys/class/thermal"):
            if "thermal_zone" in tz:
                zone_type = read_single_line("/sys/class/thermal/%s/type" % tz)
                zone_temp = read_single_line("/sys/class/thermal/%s/temp" % tz)
                if zone_temp:
                    fmt = "%0.0f%s" % (float(zone_temp) / 1000.0, GRAPH_CHAR['degree'])
                else:
                    fmt = 'n/a'
                self.thermal_zones.append(ThermalZone(zone_type, fmt))

class MemInfoSnapshot:
    def __init__(self):
        self.values = {}
        with open("/proc/meminfo") as f:
            txt = f.read()
            for l in txt.splitlines():
                kv = l.split(":")
                self.values[kv[0]] = kv[1].strip()

class MemMapsSnapshot:
    def __init__(self, pid):
        try:
            self.rw_mem = self._calc_sum(pid)
        except PermissionError:
            self.rw_mem = 0;
        except FileNotFoundError:
            self.rw_mem = 0;

    def _calc_sum(self, pid):
        sum = 0
        with open("/proc/%d/maps" % pid) as f:
            for l in f.read().splitlines():
                parts = l.split(" ")
                addr = parts[0].split("-")
                if "rw" in parts[1]:
                    low = int(addr[0], 16)
                    high = int(addr[1], 16)
                    sum += (high -low)
        return sum


class CpuInfo:
    def __init__(self, values):
        s = self
        s.user, s.nice, s.system, s.idle, s.iowait, s.irq, s.softirq, s.steal, s.guest, s.guest_nice = values

    def time_since_boot(self):
        return (
            self.user + self.nice + 
            self.system + self.idle + 
            self.iowait + self.irq + 
            self.softirq + self.steal
        )

    def idle_time_since_boot(self):
        return self.idle + self.iowait

    def usage_time_since_boot(self):
        return self.time_since_boot() - self.idle_time_since_boot()

class CpuSnapshot:
    def __init__(self):
        self.single_cpu_infos = []
        self.total_cpu_info = None
        with open("/proc/uptime", 'r') as f:
            self.uptime = float(f.read().split(" ")[0])
        with open("/proc/stat", 'r') as f:
            for line in f.read().splitlines():
                if line.startswith("cpu "): # global
                    self.total_cpu_info = CpuInfo([int(v) for v in line.split(" ")[2:]])
                elif line.startswith("cpu"): # per core
                    self.single_cpu_infos.append(CpuInfo([int(v) for v in line.split(" ")[1:]]))
                else:
                    pass # ignore this line

    def format_uptime(self):
        t = int(self.uptime)
        return time_to_str(t, True)


class Process:
    def __init__(self, uid, stat_items):
        self.uid = uid
        self.stat_items = stat_items
        self.pid = int(stat_items[0])
        self.ppid = int(stat_items[3])
        self.starttime = int(stat_items[22])
        self.parent = None
        self.child_processes = []

class ProcessInfo:
    def __init__(self, selinux_enabled, uptime, uid, pid, state, ppid, comm, utime, stime, cutime, cstime, starttime, vsize):
        self.uptime = uptime
        self.uid = uid
        self.pid = pid
        self.state = state
        self.ppid = ppid
        self.comm = comm
        self.utime = utime
        self.stime = stime
        self.cutime = cutime
        self.cstime = cstime
        self.starttime = starttime
        self.vsize = vsize
        self.children = []
        self.parent = None

        if selinux_enabled:
            fullstr = read_single_line("/proc/{}/attr/current".format(pid))
            if fullstr:
                fullstr = fullstr[:-1]
                parts = fullstr.split(':')
                self.selinux_1 = ":".join(parts[:3])
                if len(parts) >= 4:
                    self.selinux_2 = parts[3]
                    if len(parts) >= 5:
                        self.selinux_3 = ":".join(parts[4:])
                    else:
                        self.selinux_3 = ""
                else:
                    self.selinux_2 = ""
                    self.selinux_3 = ""
            else:
                self.selinux_1 = "?"
                self.selinux_2 = "?"
                self.selinux_3 = "?"
        else:
            self.selinux_1 = None
            self.selinux_2 = None
            self.selinux_3 = None
        
    def get_state_text(self):
        if self.state in PROC_STAT_DESC:
            return PROC_STAT_DESC[self.state]
        else:
            return "Unknown %s" % self.state

    def running_time(self):
        return time_to_str(self.uptime -  self.starttime / CLOCK_TICKS, True)

    def start_time(self):
        return time_to_str((time.time() -  time.timezone) - (self.uptime - self.starttime / CLOCK_TICKS), True)

class ProcessTreeLine:
    def __init__(self, user_snapshot, process_delta, max_pid, process_info, parents_last, this_last):
        self.process_info = process_info
        self.parents_last = parents_last
        self.this_last = this_last
        self.max_pid = max_pid
        self.values = {}
        try:
            self.values['UID'] = user_snapshot.username_by_uid[process_info.uid]
        except KeyError:
            logging.error("User {} not found in /etc/passwd".format(process_info.uid))
            self.values['UID'] = str(process_info.uid)
        try:
            self.values['PID'] = str(process_info.pid)
            self.values['PPID'] = str(process_info.ppid)
            self.values['STIME'] = time_to_str(self.process_info.starttime, False)
            self.values['VSIZE'] = str(int(process_info.vsize/1000000)).rjust(6)+" MB"
            self.values['CPU'] = "%d%%" % int(process_delta.cpu_usage(process_info.pid))
            self.values['COMMAND'] = self.get_command_str()
        except Exception:
            logging.error(traceback.format_exc())
            self.values['UID'] = "?"
            self.values['PID'] = "?"
            self.values['PPID'] = "?"
            self.values['STIME'] = "?"
            self.values['VSIZE'] = "?"
            self.values['CPU'] = "?"
            self.values['COMMAND'] = "?"
            
    def get_command_str(self):
        s = ""
        tc = TREE_CHARS
        for pl in self.parents_last:
            if pl:
                s += tc.vert_last
            else:
                s += tc.vert_not_last
        if self.this_last:
            s += tc.this_last
        else:
            s += tc.this_not_last
        s += self.process_info.comm 
        return s

def split_process_info_line(line):
    try:
        split1 = line.split("(" * line.count("("))
        before = split1[0][:-1]
        split2 = split1[1].split(")" * line.count("("))
        mid = split2[0]
        after = split2[1][1:]
        result = before.split(" ") + [mid] + after.split(" ")
        return result
    except:
        raise Exception(line)

def split_process_info_line_quick(line):
    result = []
    current = ""
    mode = 'N'
    for c in line:
        if mode == 'N':
            if c == ' ':
                pass
            elif c == '(':
                mode = 'B'
            else:
                mode = 'T'
                current += c
        elif mode == 'B':
            if c == '(':
                mode = 'BB'
            elif c == ')':
                result.append(current)
                current = ""
                mode = 'N'
            else:
                current += c
        elif mode == 'BB':
            if c == ')':
                mode = 'B'
            else:
                current += c
        elif mode == 'T':
            if c == ' ':
                result.append(current)
                current = ""
                mode = 'N'
            else:
                current += c
        else:
            raise Exception("Unexpected mode {}".format(mode))
    if current:
        result.append(current)
    return result

class ProcessSnapshot:
    def __init__(self, selinux_enabled, user_snapshot, uptime, command_cache):
        self.selinux_enabled = selinux_enabled
        self.user_snapshot = user_snapshot
        self.uptime = uptime
        self.command_cache = command_cache

    @staticmethod
    def read_all_pids():
        pids = []
        for l in os.listdir("/proc"):
            try:
                pids.append(int(l))
            except ValueError:
                # l is not a number => ignore it
                pass
        return pids


    @staticmethod
    def read_processes():
        all_processes = []
        zero_process = Process(0, ['0', "", "", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"])
        process_by_pid = {}
        process_by_pid[0] = zero_process
        for pid in ProcessSnapshot.read_all_pids():
            line = read_single_line("/proc/%d/stat" % pid)
            if line:
                
                uid = -1
                with open("/proc/%d/status" % pid, 'r') as f:
                    try:
                        lines = f.read().splitlines()
                    except:
                        uid = 0
                    else:
                        for l in lines:
                            if l.startswith("Uid:"):
                                parts = l.split("\t")
                                uid = int(parts[1])
                                break
                p = Process(uid, split_process_info_line_quick(line))
                all_processes.append(p)
                process_by_pid[pid] = p

        for p in all_processes:
            if p.ppid in process_by_pid:
                pp = process_by_pid[p.ppid]
                pp.child_processes.append(p)
                p.parent = pp
            else:
                raise Exception("Didn't find parent process for {}".format(p.stat_items))
        return zero_process

    @staticmethod
    def _read_process_info_list(selinux_enabled, uptime, command_cache, filter):
        t0 = time.monotonic()
        result =  []
        all_pids = ProcessSnapshot.read_all_pids()
        for pid in all_pids:
            line = read_single_line("/proc/%d/stat" % pid)
            if line:
                p = split_process_info_line(line)
                if pid != int(p[0]):
                    raise Exception("Nasty inconsistency for %d: %s" % (pid, p[0]))
                command_line = command_cache.get_command(pid, int(p[22]))
                starttime = float(p[21])
                uid = -1
                with open("/proc/%d/status" % pid, 'r') as f:
                    try:
                        lines = f.read().splitlines()
                    except:
                        uid = 0
                    else:
                        for l in lines:
                            if l.startswith("Uid:"):
                                parts = l.split("\t")
                                uid = int(parts[1])
                                break
                result.append(ProcessInfo(
                    selinux_enabled,
                    uptime,
                    uid,
                    pid,
                    p[2],
                    int(p[3]),
                    command_line,
                    int(p[12]),
                    int(p[13]),
                    int(p[14]),
                    int(p[15]),
                    starttime,
                    int(p[22])
                ))
        return result
    @staticmethod
    def get_all_descendants(process_info):
        children = []
        for c in process_info.children:
            children.append(c)
            children.extend(ProcessSnapshot.get_all_descendants(c))
        return children
		
    def get_all_descendant_pis(self, pi):
        children = []
        for c in self.process_list:
            if c.ppid == pi.pid:
                children.append(c)
                children.extend(self.get_all_descendant_pis(c))
        return children
    @staticmethod
    def _add_lines(user_snapshot, process_delta, max_pid, lines, parents_last, this_last, node, pids_to_show):
        if node.pid not in pids_to_show:
            #logging.info("OOOPS {} is not in {}".format(node.pid, pids_to_show))
            return
        lines.append(ProcessTreeLine(user_snapshot, process_delta, max_pid, node, parents_last, this_last))
        for i in range(0, len(node.children)):
            c = node.children[i]
            this_child_last = (i == len(node.children) - 1)
            new_parents_last = []
            new_parents_last.extend(parents_last)
            new_parents_last.append(this_last)
            ProcessSnapshot._add_lines(user_snapshot, process_delta, max_pid, lines, new_parents_last, this_child_last, c, pids_to_show)

    @staticmethod
    def matches_info(user_snapshot, process_info, filter_values):
        try:
            username = user_snapshot.username_by_uid[process_info.uid]
        except:
            username = '???'
        if filter_values['UID'] not in username:
            return False
        if filter_values['PID'] not in str(process_info.pid):
            return False
        if filter_values['COMMAND'] not in process_info.comm:
            return False
        return True

    @staticmethod
    def matches(actual_values, filter_values):
        for filter_key in filter_values:
            filter_value = filter_values[filter_key]
            if filter_value:
                if filter_value not in actual_values[filter_key]:
                    return False
        return True

    def get_process_lines(self, process_delta, filter = {}):

        ta0 = time.monotonic()
        root = ProcessSnapshot.read_processes()
        ta1 = time.monotonic()
        logging.info("TA {:12f}".format(ta1 - ta0))
        t0 = time.monotonic()
        self.root = ProcessInfo(self.selinux_enabled, self.uptime, 0, 0, '0', None, "Root", 0, 0, 0, 0, 0, 0)
        self.max_pid = 0
        self.process_list = [self.root]
        self.process_list.extend(ProcessSnapshot._read_process_info_list(self.selinux_enabled, self.uptime, self.command_cache, filter))
        self.process_info_by_pid = {}
        for p in self.process_list:
            if p.pid > self.max_pid:
                self.max_pid = p.pid
            self.process_info_by_pid[p.pid] = p

        pids_to_show = set()
        pids_to_show.add(0)
        for pi in self.process_list:
            if ProcessSnapshot.matches_info(self.user_snapshot, pi, filter):
                up = pi
                while up is not None and up != self.root and not up.pid in pids_to_show:
                    pids_to_show.add(up.pid)
                    up = self.process_info_by_pid[up.ppid]
                for pic in self.get_all_descendant_pis(pi):
                    pids_to_show.add(pic.pid)


        for p in self.process_list:
            if not(p.ppid is None) and p.pid in pids_to_show:
                self.process_info_by_pid[p.ppid].children.append(p)
                p.parent = self.process_info_by_pid[p.ppid]

        lines = []
        ProcessSnapshot._add_lines(self.user_snapshot, process_delta, self.max_pid, lines, [], True, self.root, pids_to_show)

        t1 = time.monotonic()

        logging.info("TO {:12f}".format(t1 - t0))
        return lines

class Snapshot:
    def __init__(self, selinux_enabled, user_snapshot, command_cache):
        self.cpu_snapshot = CpuSnapshot()
        self.process_snapshot = ProcessSnapshot(selinux_enabled, user_snapshot, self.cpu_snapshot.uptime, command_cache)


class CpuDelta:
    def __init__(self, cpu_snapshot1, cpu_snapshot2):
        self.cpu_percentages = []
        self.uptime_str = cpu_snapshot2.format_uptime()
        usage_after = cpu_snapshot2.total_cpu_info.usage_time_since_boot()
        usage_before = cpu_snapshot1.total_cpu_info.usage_time_since_boot()
        tot_delta_usage_time = usage_after - usage_before
        time_after = cpu_snapshot2.total_cpu_info.time_since_boot()
        time_before = cpu_snapshot1.total_cpu_info.time_since_boot()
        tot_delta_time = time_after - time_before
        if tot_delta_time > 0:
            p = tot_delta_usage_time * 100 / tot_delta_time
            self.total_cpu_percentage = p
        else:
            self.total_cpu_percentage = 0
        ci1 = cpu_snapshot1.single_cpu_infos
        ci2 = cpu_snapshot2.single_cpu_infos
        if len(ci1) != len(ci2):
            logging.error("#cpu_infos: {} vs {}".format(len(ci1), len(ci2)))
            for l in ci1:
                logging.error("  (1) : {}".format(l))
            for l in ci2:
                logging.error("  (2) : {}".format(l))
        for i in range(0, min(len(ci1), len(ci2))):
            s1 = cpu_snapshot1.single_cpu_infos[i]
            s2 = cpu_snapshot2.single_cpu_infos[i]
            delta_usage_time = s2.usage_time_since_boot() - s1.usage_time_since_boot()
            delta_time = s2.time_since_boot() - s1.time_since_boot()
            if delta_time > 0:
                p = delta_usage_time * 100 / delta_time
                self.cpu_percentages.append(p)
            else:
                self.cpu_percentages.append(0)


class SingleProcessDelta:
    def __init__(self, utime, stime, cutime, cstime):
        self.utime = utime
        self.stime = stime
        self.cutime = cutime
        self.cstime = cstime

class ProcessDelta:
    def __init__(self, process_snapshot1, process_snapshot2):
        self.process_snapshot1 = process_snapshot1
        self.process_snapshot2 = process_snapshot2

    def get_single_process_delta(self, pid):
        pi1 = self.process_snapshot1.process_info_by_pid[pid]
        pi2 = self.process_snapshot2.process_info_by_pid[pid]
        if pi1 and pi2:
            du = pi2.utime - pi1.utime
            ds = pi2.stime - pi1.stime
            cu = pi2.cutime - pi1.cutime
            cs = pi2.cstime - pi1.cstime
            return SingleProcessDelta(du, ds, cu, cs)
        else:
            return None

    def cpu_usage(self, pid):
        try:
            info1 = self.process_snapshot1.process_info_by_pid[pid]
            info2 = self.process_snapshot2.process_info_by_pid[pid]
        except:
            #logging.error(traceback.format_exc())
            return 0
        

        total_time_1 = info1.utime + info1.stime
        total_time_2 = info2.utime + info2.stime
        delta_total = total_time_2 - total_time_1
        seconds = info2.uptime - info1.uptime
        return 100.0 * ((delta_total / CLOCK_TICKS) / seconds)

class Delta:
    def __init__(self, snapshot1, snapshot2):
        self.cpu_delta = CpuDelta(snapshot1.cpu_snapshot, snapshot2.cpu_snapshot)
        self.process_delta = ProcessDelta(snapshot1.process_snapshot, snapshot2.process_snapshot)


class JillModel:
    def __init__(self):
        self.delta = None
        self.selinux_info = SELinuxInfo()
        self.apparmor_info = AppArmorInfo()
        self.command_cache = CommandCache()
        self.battery_paths = find_battery_paths()
        self.thermal_info = ThermalInfo()
        user_snapshot = UserSnapshot()
        self.snapshot = Snapshot(self.selinux_info(), user_snapshot, self.command_cache)
        self.mem_info_snapshot = MemInfoSnapshot()
        self.power_infos = {}
        for p in self.battery_paths:
            self.power_infos[p] = PowerInfo(p)

    def time_tick(self):
        self.selinux_info.reload()
        new_snapshot = Snapshot(self.selinux_info(), UserSnapshot(), self.command_cache)
        self.delta = Delta(self.snapshot, new_snapshot)
        self.mem_info_snapshot = MemInfoSnapshot()
        self.thermal_info = ThermalInfo()
        for p in self.battery_paths:
            self.power_infos[p].take_snapshot()
        self.snapshot = new_snapshot




import os
import logging
import time



LOG_FOLDER = os.path.expanduser('~/log')

if os.path.exists(LOG_FOLDER):
    if not os.path.isdir(LOG_FOLDER):
        raise Exception("%s found, but it's not a directory" % LOG_FOLDER)
else:
    os.mkdir(LOG_FOLDER)
logging.basicConfig(filename=os.path.join(LOG_FOLDER, 'jill.log'),level=logging.DEBUG)

class ViewModel:
    def __init__(self):
        self.selected_pid = None

class SELinuxComponent(Table):
    def __init__(self, selinux_info):
        super(SELinuxComponent, self).__init__()
        self.selinux_info = selinux_info
        self.stretch_x = True

    def update_from_model(self):
        self.clear_table()
        self.set_value(0, 0, "Status")
        self.set_value(0, 1, self.selinux_info.status)
        self.set_value(1, 0, "Policy")
        self.set_value(1, 1, self.selinux_info.policy)
        self.set_value(2, 0, "Mode")
        self.set_value(2, 1, self.selinux_info.mode)
        self.set_value(3, 0, "MLS")
        self.set_value(3, 1, self.selinux_info.mls)
 
class AppArmorComponent(Table):
    def __init__(self, apparmor_info):
        super(AppArmorComponent, self).__init__()
        self.apparmor_info = apparmor_info
        self.stretch_x = True

    def update_from_model(self):
        self.clear_table()
        self.set_value(0, 0, "Enabled")
        self.set_value(0, 1, str(self.apparmor_info.enabled))

        info = self.apparmor_info
        for index, m in enumerate(sorted(info.count_mode.keys())):
            self.set_value(index + 1, 0, m)
            self.set_value(index + 1, 1, str(info.count_mode[m]) + " profiles")

class CpuUsageComponent(Table):
    def __init__(self, jill_model, core_columns):
        super(CpuUsageComponent, self).__init__()
        self.stretch_x = True
        self.jill_model = jill_model
        self.core_columns = core_columns

    def update_from_model(self):
        self.clear_table()
        d = self.jill_model.delta
        if d:
            self.set_value(0, 0, "Uptime")
            self.set_value(1, 0, "Total")
            self.set_value(2, 0, "Per Core")
            self.set_value(0, 1, d.cpu_delta.uptime_str)
            self.set_value(1, 1, ("%d%%" % d.cpu_delta.total_cpu_percentage))
            lines = partition(d.cpu_delta.cpu_percentages, self.core_columns)
            for y, cpus_per_line in enumerate(lines, start=2):
                self.set_value(y, 1, " ".join(("%d%%" % c) for c in cpus_per_line))


class MemUsageComponent(Table):
    def __init__(self, jill_model):
        super(MemUsageComponent, self).__init__()
        self.stretch_x = True
        self.jill_model = jill_model
        self.set_value(0, 0, "Total")
        self.set_value(1, 0, "Free")
        self.set_value(2, 0, "Avail")

    def _format(self, val):
        parts = val.split()
        if len(parts) == 2 and parts[1].upper() in MEM_UNITS:
            return format_memory(float(parts[0]), parts[1].upper())
        else:
            return val

    def update_from_model(self):
        mi = self.jill_model.mem_info_snapshot
        self.set_value(0, 1, self._format(mi.values['MemTotal']))
        self.set_value(1, 1, self._format(mi.values['MemFree']))
        self.set_value(2, 1, self._format(mi.values['MemAvailable']))

class BatteryStatusComponent(Table):
    def __init__(self, model, path):
        super(BatteryStatusComponent, self).__init__()
        self.stretch_x = True
        self.model = model
        self.path = path

    def update_from_model(self):
        pi = self.model.power_infos[self.path]
        self.clear_table()
        self.set_value(0, 0, "Status")
        self.set_value(0, 1, pi.status)
        self.set_value(1, 0, "Charge")
        self.set_value(1, 1, "{}%".format(pi.capacity))
        if pi.time_remaining_str:
            self.set_value(2, 0, "Time left")
            self.set_value(2, 1, pi.time_remaining_str)

class TemperatureComponent(Table):
    def __init__(self, model):
        super(TemperatureComponent, self).__init__(row_limit=4)
        self.stretch_x = True
        self.model = model
        self.can_focus = len(model.thermal_info.thermal_zones) > 4

    def update_from_model(self):
        for y, z in enumerate(self.model.thermal_info.thermal_zones):
            self.set_value(y, 0, z.zone_type)
            self.set_value(y, 1, z.zone_temp)

class ProcessInfoComponent(FilterTable):
    def __init__(self, model, view_model):
        cols = [
            TableColumn('UID', max_width=8),
            TableColumn('PID', max_width=5),
            TableColumn('PPID', max_width=5, visible=False),
            TableColumn('CPU', max_width=4),
            TableColumn('COMMAND', max_width=800)
        ]
        super(ProcessInfoComponent, self).__init__(cols, always_highlight_selection=True)
        self.min_height = 6
        self.stretch_x = True
        self.stretch_y = True
        self.model = model
        self.view_model = view_model
        self.process_snapshot = self.model.snapshot.process_snapshot
        self.selected_line = 0
        self.selected_pids = []

    def update_from_model(self):
        self.remember_selection()
        self.process_snapshot = self.model.snapshot.process_snapshot
        self.clear_table()
        process_delta = self.model.delta.process_delta
        row = 0
        for row, l in enumerate(self.process_snapshot.get_process_lines(process_delta, self.search_values())):
            self.set_value(row, 0, l.values['UID'])
            self.set_value(row, 1, l.values['PID'])
            self.set_value(row, 2, str(l.process_info.ppid) if l.process_info.ppid else "")
            self.set_value(row, 3, l.values['CPU'].rjust(4))
            self.set_value(row, 4, l.values['COMMAND'])

        self.reselect()
        self.view_model.selected_pid = self.get_selected_pid()

    def get_selected_pid(self):
        row =  self.table._data[self.table.selected_row_index]
        return row[1]

    def insert_selected_pids(self, index):
        row = self.table._data[index]
        self.selected_pids.insert(0, row[2] if row[2] else "0")
        ppid = row[2]
        if not ppid:
            return
        if int(ppid) > 0:
            for i in range(0, len(self.table._data)):
                if self.table._data[i][1] == ppid:
                    self.insert_selected_pids(i)
                    return

    def remember_selection(self):
        self.selected_pids = []
        if len(self.table._data) == 0:
            return
        self.insert_selected_pids(self.table.selected_row_index)
        self.selected_pids.append(self.table._data[self.table.selected_row_index][1])

    def reselect(self):
        sel_row_index = 0
        sel_ix = 0
        for data_ix in range(0, len(self.table._data)):
            if sel_ix < len(self.selected_pids) and self.table._data[data_ix][1] == self.selected_pids[sel_ix]:
                sel_row_index = data_ix
                sel_ix += 1
        self.table.selected_row_index = sel_row_index

class ProcessDetailsComponent(Table):
    def __init__(self, model, view_model):
        super(ProcessDetailsComponent, self).__init__(row_limit=5)
        self.stretch_x = True
        self.model = model
        self.view_model = view_model

    def update_from_model(self):
        self.clear_table()
        pid = self.view_model.selected_pid
        if pid == "0" or pid is None:
            pid = None
        else:
            pid = int(pid)

        if not pid:
            self.set_value(0, 0, "n/a")
            return
        process_info = self.model.snapshot.process_snapshot.process_info_by_pid[pid]
        process_delta = self.model.delta.process_delta
 
        spd = process_delta.get_single_process_delta(pid) 

        if process_info.state in PROC_STAT_DESC: 
            state = PROC_STAT_DESC[process_info.state] 
        else: 
            state = "?" 
        utime = spd.utime 
        stime = spd.stime 
        cutime = spd.cutime 
        cstime = spd.cstime 
           
        mms = MemMapsSnapshot(pid) 
        mem_net = mms.rw_mem 
        mem_gross = process_info.vsize 

        width_col_1 = self.col_widths[1] if len(self.col_widths) > 1 else 5
        self.set_value(0, 0, "Command")
        self.set_value(0, 1, process_info.comm[:width_col_1])
        self.set_value(0, 2, "CPU")
        self.set_value(0, 3, "%d%% / %s" % (int(process_delta.cpu_usage(pid)), state) )
        self.set_value(1, 0, "PID/PPID")
        self.set_value(1, 1, "{}/{}".format(pid, process_info.ppid))
        self.set_value(1, 2, "Running Time")
        self.set_value(1, 3, "{} (started {})".format(process_info.running_time(), process_info.start_time()))
        self.set_value(2, 0, "U/S TIME")
        self.set_value(2, 1, "{}/{}".format(utime, stime))
        self.set_value(2, 2, "CU/CS TIME")
        self.set_value(2, 3, "{}/{}".format(cutime, cstime))
        self.set_value(3, 0, "Mem Net")
        self.set_value(3, 1, format_memory(mem_net))
        self.set_value(3, 2, "Mem Gross")
        self.set_value(3, 3, format_memory(mem_gross))
        if self.model.selinux_info():
            self.set_value(4, 0, "SELinux")
            self.set_value(4, 1, process_info.selinux_1)
            self.set_value(4, 2, process_info.selinux_2)
            self.set_value(4, 3, process_info.selinux_3)
        elif self.model.apparmor_info():
            aa =  self.model.apparmor_info
            self.set_value(4, 0, "AppArmor")
            if pid in aa.pids:
                self.set_value(4, 1, aa.process_status[pid])
                self.set_value(4, 2, "Profile")
                self.set_value(4, 3, aa.process_profile[pid])
            else:
                self.set_value(4, 1, "n/a")

class MainJillView(VerticalFlow):
        def __init__(self, model):
            super(MainJillView, self).__init__()

            view_model = ViewModel()

            ti = ThermalInfo()
            selinux_info = model.selinux_info
            apparmor_info = model.apparmor_info

            top_boxes_count = 2 + len(model.battery_paths) + (1 if ti.thermal_zones else 0) + (1 if selinux_info() else 0)

            top_line = HorizontalFlow()

            if selinux_info():
                selinux = SELinuxComponent(selinux_info)
                top_line.add(TitledBorder("SELinux", selinux))
            if apparmor_info():
                apparmor = AppArmorComponent(apparmor_info)
                top_line.add(TitledBorder("AppArmor", apparmor))

            cpu = CpuUsageComponent(model, 4 if top_boxes_count >=4 else 8)
            top_line.add(TitledBorder("CPU", cpu))

            mem = MemUsageComponent(model)
            top_line.add(TitledBorder("Memory", mem))

            for p in model.battery_paths:
                batt = BatteryStatusComponent(model, p)
                top_line.add(TitledBorder(p, batt))

            if ti.thermal_zones:
                temp = TemperatureComponent(model)
                top_line.add(TitledBorder("Temperature", temp))
            
            self.add(top_line)

            procInfo = ProcessInfoComponent(model, view_model)
            mid_line = HorizontalFlow()
            mid_line.add(TitledBorder("Processes", procInfo))
            self.add(mid_line)

            procDetails = ProcessDetailsComponent(model, view_model)
            low_line = HorizontalFlow()
            low_line.add(TitledBorder("Process Details", procDetails))
            self.add(low_line)

class JillScreen(Screen):
    def __init__(self):
        self.rows = 0
        self.cols = 0
        self.model = JillModel()
        self.view = MainJillView(self.model)
        super(JillScreen, self).__init__(self.view)

    def resized(self, rows, cols):
        if self.rows != rows or self.cols != cols:
            self.rows = rows
            self.cols = cols
            self.view.layout(self.cols - 1, self.rows)

    def time_tick(self, force_layout=False):
        t1 = time.monotonic()
        self.model.time_tick()
        t2 = time.monotonic()
        self.view.update_from_model()
        t3 = time.monotonic()
        if force_layout or not self.view.layout_valid:
            self.view.layout(self.cols - 1, self.rows)
        t4 = time.monotonic()
        logging.info("Timetick: {:5.3f} / {:5.3f} / {:5.3f} => {:5.3f}".format(t2 - t1, t3 - t2, t4 - t3, t4 - t1))

class JillApp:
    def start(self):
        with curses_tui(halfdelay=10) as t:
            js = JillScreen()
            t.add_screen(js)
            t.event_loop()

app = JillApp()
app.start()
